From 3520a6e69bb7db52c91381592dd54075710a2e4c Mon Sep 17 00:00:00 2001
From: Cyber <1322816443@qq.com>
Date: Wed, 18 Sep 2024 15:32:34 +0800
Subject: [PATCH] adjust ws_session

---
 gcnet/ws_server/ws_option.go |  16 +++--
 gcnet/ws_server/ws_server.go |   6 +-
 gcnet/ws_session/session.go  | 123 ++++-------------------------------
 iface/isession.go            |   1 +
 4 files changed, 32 insertions(+), 114 deletions(-)

diff --git a/gcnet/ws_server/ws_option.go b/gcnet/ws_server/ws_option.go
index bbc6e59..8175ae6 100644
--- a/gcnet/ws_server/ws_option.go
+++ b/gcnet/ws_server/ws_option.go
@@ -2,6 +2,7 @@ package ws_server
 
 import (
 	"github.com/v587-zyf/gc/iface"
+	"net/http"
 )
 
 type WsOption struct {
@@ -11,6 +12,7 @@ type WsOption struct {
 
 	https bool
 
+	wsFunc func(http.ResponseWriter, *http.Request)
 	method iface.IWsSessionMethod
 }
 
@@ -40,14 +42,20 @@ func WithKey(key string) Option {
 	}
 }
 
-func WithMethod(m iface.IWsSessionMethod) Option {
+func WithHttps(https bool) Option {
 	return func(opts *WsOption) {
-		opts.method = m
+		opts.https = https
 	}
 }
 
-func WithHttps(https bool) Option {
+func WithWsFunc(wsFunc func(http.ResponseWriter, *http.Request)) Option {
 	return func(opts *WsOption) {
-		opts.https = https
+		opts.wsFunc = wsFunc
+	}
+}
+
+func WithMethod(m iface.IWsSessionMethod) Option {
+	return func(opts *WsOption) {
+		opts.method = m
 	}
 }
diff --git a/gcnet/ws_server/ws_server.go b/gcnet/ws_server/ws_server.go
index f66375a..8b320b8 100644
--- a/gcnet/ws_server/ws_server.go
+++ b/gcnet/ws_server/ws_server.go
@@ -54,7 +54,11 @@ func (s *WsServer) Start() {
 
 	r.HandleFunc("/api/test", s.test).Methods("GET")
 	r.HandleFunc("/api/webHook", s.webHook).Methods("POST")
-	r.HandleFunc("/ws", s.wsHandle).Methods("GET")
+	if s.options.wsFunc != nil {
+		r.HandleFunc("/ws", s.options.wsFunc).Methods("GET")
+	} else {
+		r.HandleFunc("/ws", s.wsHandle).Methods("GET")
+	}
 
 	var err error
 	if s.options.https {
diff --git a/gcnet/ws_session/session.go b/gcnet/ws_session/session.go
index 2d292ff..8b7cef1 100644
--- a/gcnet/ws_session/session.go
+++ b/gcnet/ws_session/session.go
@@ -58,13 +58,6 @@ func NewSession(ctx context.Context, conn *websocket.Conn) *Session {
 func (s *Session) Start() {
 	go s.readPump()
 	go s.IOPump()
-	//go func() {
-	//	s.parsePump()
-	//}()
-	//
-	//go func() {
-	//	s.writePump()
-	//}()
 }
 
 func (s *Session) Hooks() *Hooks {
@@ -102,8 +95,6 @@ func (s *Session) SetID(id uint64) {
 }
 
 func (s *Session) Close() error {
-	// return s.Conn.Close()
-	//log.Info("session close", zap.Int32("sessID", s.GetID()))
 	s.once.Do(func() {
 		s.cancel()
 		s.conn.Close()
@@ -120,6 +111,20 @@ func (s *Session) GetCtx() context.Context {
 	return s.ctx
 }
 
+func (s *Session) SendMsg(fn func(args ...any) ([]byte, error), args ...any) error {
+	sendBytes, err := fn(args...)
+	if err != nil {
+		return err
+	}
+
+	select {
+	case s.outChan <- sendBytes:
+		return nil
+	default:
+		return errcode.ERR_NET_SEND_TIMEOUT
+	}
+}
+
 func (s *Session) Send(msgID uint16, tag uint32, userID uint64, msg iface.IProtoMessage) error {
 	buf := new(bytes.Buffer)
 
@@ -192,7 +197,6 @@ LOOP:
 			break LOOP
 		}
 		if message != nil && len(message) > 0 {
-			//log.Debug("1------------------recv msg")
 			dataCopy := make([]byte, len(message))
 			copy(dataCopy, message)
 			s.inChan <- dataCopy
@@ -220,9 +224,6 @@ func (s *Session) IOPump() {
 		}
 	}()
 
-	heartbeatTicker := time.NewTicker(enums.HEARTBEAT_INTERVAL)
-	defer heartbeatTicker.Stop()
-
 LOOP:
 	for {
 		select {
@@ -238,9 +239,6 @@ LOOP:
 					zap.Uint16("msgID", msgID), zap.Int("len", len(data)), zap.Error(err))
 				break LOOP
 			}
-		case <-heartbeatTicker.C:
-			//msg := new(pb.Heartbeat)
-			//s.Send2User(pb.MsgID_HeartbeatId, msg)
 		case <-s.ctx.Done():
 			break LOOP
 		}
@@ -250,96 +248,3 @@ LOOP:
 
 	s.Close()
 }
-
-//func (s *Session) parsePump() {
-//	defer func() {
-//		if r := recover(); r != nil {
-//			buf := make([]byte, 1<<10)
-//			runtime.Stack(buf, true)
-//			if err, ok := r.(error); ok {
-//				log.Error("core dump", zap.Uint64("sessID", s.GetID()),
-//					zap.String("err", err.Error()), zap.ByteString("core", buf))
-//			} else if err, ok := r.(string); ok {
-//				log.Error("core dump", zap.Uint64("sessID", s.GetID()),
-//					zap.String("err", err), zap.ByteString("core", buf))
-//			} else {
-//				log.Error("core dump", zap.Uint64("sessID", s.GetID()),
-//					zap.Reflect("err", err), zap.ByteString("core", buf))
-//			}
-//		}
-//	}()
-//
-//LOOP:
-//	for {
-//		select {
-//		case data := <-s.inChan:
-//			s.hooks.ExecuteRecv(s, data)
-//		case <-s.ctx.Done():
-//			break LOOP
-//		}
-//	}
-//}
-//
-//func (s *Session) writePump() {
-//	defer func() {
-//		if r := recover(); r != nil {
-//			buf := make([]byte, 1<<10)
-//			runtime.Stack(buf, true)
-//			if err, ok := r.(error); ok {
-//				log.Error("core dump", zap.Uint64("sessID", s.GetID()),
-//					zap.String("err", err.Error()), zap.ByteString("core", buf))
-//			} else if err, ok := r.(string); ok {
-//				log.Error("core dump", zap.Uint64("sessID", s.GetID()),
-//					zap.String("err", err), zap.ByteString("core", buf))
-//			} else {
-//				log.Error("core dump", zap.Uint64("sessID", s.GetID()),
-//					zap.Reflect("err", err), zap.ByteString("core", buf))
-//			}
-//		}
-//	}()
-//
-//LOOP:
-//	for {
-//		select {
-//		case data := <-s.outChan:
-//			s.conn.SetWriteDeadline(time.Now().Add(enums.CONN_WRITE_WAIT_TIME))
-//
-//			err := s.conn.WriteMessage(websocket.BinaryMessage, data)
-//			if err != nil {
-//				msgID := binary.BigEndian.Uint16(data[0:2])
-//				log.Warn("conn write err", zap.Uint64("userID", s.id),
-//					zap.Uint16("msgID", msgID), zap.Int("len", len(data)), zap.Error(err))
-//				break LOOP
-//			}
-//		case <-s.ctx.Done():
-//			break LOOP
-//		}
-//	}
-//
-//	s.conn.Close()
-//	s.cancel()
-//
-//	s.hooks.ExecuteStop(s)
-//}
-//
-//func (s *Session) split(data []byte, atEOF bool) (advance int, token []byte, err error) {
-//	if atEOF && len(data) == 0 {
-//		return 0, nil, nil
-//	}
-//	dataLen := len(data)
-//	if dataLen < enums.MSG_HEADER_SIZE {
-//		return 0, nil, nil
-//	}
-//
-//	// body len
-//	n := int(binary.BigEndian.Uint32(data[0:4]))
-//	if n > enums.MSG_MAX_PACKET_SIZE-enums.MSG_HEADER_SIZE || n < 0 {
-//		log.Error("body len invalid", zap.Uint64("sessID", s.id),
-//			zap.Int("n", n), zap.String("addr", s.GetConn().RemoteAddr().String()))
-//		return 0, nil, errcode.ERR_NET_BODY_LEN_INVALID
-//	}
-//	if dataLen < n+enums.MSG_HEADER_SIZE {
-//		return 0, nil, nil
-//	}
-//	return n + enums.MSG_HEADER_SIZE, data[0 : n+enums.MSG_HEADER_SIZE], nil
-//}
diff --git a/iface/isession.go b/iface/isession.go
index 3eb55df..6ae1a7d 100644
--- a/iface/isession.go
+++ b/iface/isession.go
@@ -37,6 +37,7 @@ type IWsSession interface {
 	GetConn() *websocket.Conn
 	GetCtx() context.Context
 
+	SendMsg(fn func(args ...any) ([]byte, error), args ...any) error
 	Send(msgID uint16, tag uint32, userID uint64, msg IProtoMessage) error
 	Send2User(msgID uint16, msg IProtoMessage) error
 
-- 
2.43.0.windows.1

